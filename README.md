# r
Rust no more; "TRust programming language"

The TRust programming language, for the user; Bringing back the object oriented/imperative programming paradigm, to program like its the 90s again (albeit a modern take on OOP) and experimenting with how to code in a more natural way (see the last paragraph to understand authoritization around a language and its intrinsic value, and who has the final say)

There's a version of pointers and references that I'm still thinking about—how we can approach (the dot (.)) that which i'll elaborate on at a later time; and how i think it should work, as well as references; And, alongside the object-oriented/imperative models. I can see a world where these things exist in such a way, that its like: *"duh, why didnt anyone think of it before"*.

Implicit types could be expressed as a "trait" or maybe like an "impish trait", lol iuno, thats a work in progress I guess, logically speaking. Things like struct embeddings would make it easier to mix and match behaviors without rigid hierarchies, and I think we are leaning towards something like this... It would also be important to change the idea of namespaces, splitting it into different aspects (I dont like when modules are solving the part of name conflicts and such). However in the case where we find **namespace** to be simpler for some reason or another, `-identifiers=idiosyncratic`, meaning they are all unique names that the programmer should either read as such, or should comply to; Otherwise its assumed that they should proceed per usual — which is more like, one way we could navigate that complex situation that I'd rather have solved via the language semantics/conventions; But that's one example.

Taking a step back, the language should be a **freeform object language**. So alot of these things should depend on **how well they play into the idea of a freeform object space**. Many things would be kindve different, but in the sense that it would be **a simplification**. There are things about Rust that are okay in terms of the sentiment, but that I feel like are trying to follow its predecessors, almost like a team of a million people tried to voice their opinion over a certain feature (like one in favor of Ocaml, and another in the realm of Pythonic coding, and then another into Javascript on the world wide web) and they ended up appeasing the voice of every person in that room. Tts really suppose to be following the KISS rule of **keeping it simple** in most of the fundamental areas, atleast to me, that is one of the more important philosophies.

If things are going to emulate a C/Python sortve domain of syntax, then it should get closer to it in terms of similitude (this is the case for newish things too, say closures, and those type've things...) Reference semantics are important to consider here, and I think theres a deeper problem, that which is like a deep hole, with differing schools of thought attached to it. Languages have to have a purpose, and that purpose cannot be in seventy thousand places simultaneously. Ask yourself, "Why are prototypes important, and why does C have the best flow when it comes to compiled languages?" I think it should be obvious to people, however it seems to have been swept under the table, **bad seeds start sprouting up immediately when you get rid of the C-like rationale behind ordering**—

Typically (atleast following C's perspective) its not the definitions that you are worried about, assuming you've prototyped them, as we are talking about listing function prototypes at the top of the file. What this accomplishes multiple things: For one, it assures the types in that function, both to the programmer and to the compiler; On top of this, it also reinforces good design choices, since people can look at the top of the file, or a framework file, to see what is going on, and have it infer their decision immediately going forward. Its a window into the ordering of that file's logic. So my argument (which I thought was obvious) is that, so long as there's some explicit ordering required by a language, and not arbitrary insertions, then it reinforces **good design decisions**.

So never mind whether something is suppose to be based around safety or not (or whether it should be garbage compiled or not) and how we would even do those things; I think the main focus should be based around **systems of programming**. That implies that you want to make it easier to understand the system your working with, and reinforce the programmers ability to properly order things. I mean, that alone can solve much of the stupidity, such as making sure something is safe. If you are having trouble understanding what you are looking at, then its gonna be harder to impose a judgement on whether or not it was safe in the first place (or what the code even means!)

Templates and metaprogramming: Even though I've grouped these terms together, I recognize that they are two distinct and different things. I grouped them just to express that, by default, im not a fan of either of them, and it should be assumed that I dont want TRust to have a notion of templates (generics) or anything metaprogramming related, since the idea of it is to return to the 90's, wherein those new world paradigms are but a distant cloud over the mountains of 1700 Prussia (as opposed to black locust—invasive weeds that you are trying to pick, and sort through). The metaprogramming paradigms are fairly new, and its not something that TRust would be comfortable w/, as other languages are doing the metaprogramming thing very well, and Im not gonna pretend like there's a chance that TRust could compete with them in that domain.

*I'm using the term TRust as more of lexical, hygenic tagmeme; As I've not made my mind up on the names for anything.*

In fact, I didnt really intend to make a compiled language to begin with, I just recognized its importance in the future, and things like "**trying to maintain a system w/ long strands of references and such**", could become a deeper problem down the road. So I think what TRust should be, fundamentally speaking, is a **system of programming** language that people can trust, something **for the people**, but not necessarily **by the people**. Something that does things in a way that make sense, without using any shortcuts to do it. I personally dont like fancy things anyway, although im open to some newish/newer things. But for the most part, when I hear a proposal, I'm liable to ask the question **does it improve the flow of the language or does it add to the confusion?** If it is just adding confusion for no reason, than the answer is "No", simple as that. For example, some people say *"I dont like writing "const", i dont want to use a language that has the const keyword in it..."*, that is the voice of someone who wants a language that's more **emblematized** and confusing to read (simplified at the cost of legibility) making it harder on the programmer who's job it is to point out when something is constant, who has to make sure those constants are coherent within its context. There is going to be plenty of voices like this, and the simple answer is "No".

Compiler exclamations that are triggered around identifier adjectives (like when const is illegally reassigned) is indicated in the bespoke warning or error, and is sufficiently accounted for already. As programmers, our main job is not about imposing safety or making things **harder**. If everything was about safety, then it wouldnt be programming, and it would be about auditing documents for compliances and standards. The goal of a language should be to have some direct relationship to assembly, as at some time down the road it should be boostrapped and compiled/running on its own code (unless of course its a higher level language specifically designed to be compiled to a lower level language).

Legibility is a **first and foremost** priority. Whether or not something is optimized and 100% safe is a step that should come much later, or during the auditing step. That is to say, whether or not TRust should be built around safety is a distant thought, reserved for much later, after we've examined the former options around references. Once we walk through all of these priorities first, then we can start asking quetions about these kinds of things like saftey and such. p.s. the world is changing everyday, and its important to recognize the very center of it all, the gyrating center, relative to all the changes. That's all we have to do. That's all we can do.

One last thing, the programmers themselves have the final say on whether or not a language should be used. That means that no government, no official or president, **or any high ranking person** has a say in whether or not a language is respectable. It is the developers, engineers, and communities who build, maintain, and use programming languages that determine their value and relevance. A language's worth is measured by its practicality, efficiency, and the solutions it enables, not by the endorsement or approval of any authority.

